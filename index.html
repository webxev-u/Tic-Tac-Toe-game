<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>StarPath</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body {
      background: linear-gradient(to bottom, #1a202c, #2d3748);
    }
    canvas {
      background: linear-gradient(to bottom, #000000, #1a202c);
      box-shadow: 0 0 20px rgba(255, 255, 255, 0.2);
      border-radius: 8px;
    }
    .animate-pulse {
      animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
    }
    .animate-bounce {
      animation: bounce 1s ease-in-out infinite;
    }
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }
    @keyframes bounce {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-10px); }
    }
  </style>
</head>
<body class="min-h-screen flex items-center justify-center">
  <div class="container mx-auto p-4 text-center">
    <h1 class="text-4xl font-bold text-white mb-6 animate-pulse">StarPath</h1>
    <div class="text-2xl text-white mb-4">Score: <span id="score">0</span></div>
    <div id="gameOver" class="text-3xl text-red-500 mb-4 animate-bounce hidden">Game Over!</div>
    <canvas id="gameCanvas" width="400" height="600" class="mx-auto"></canvas>
    <div class="mt-4 flex justify-center gap-4">
      <button id="orbitIn" class="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700">Orbit In</button>
      <button id="orbitOut" class="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700">Orbit Out</button>
      <button id="reset" class="px-4 py-2 bg-green-600 text-white rounded hover:bg-green-700">Reset</button>
    </div>
  </div>
  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    let score = 0;
    let gameOver = false;
    let stars = [
      { x: 150, y: 100, radius: 10, angle: 0, speed: 0.05 },
      { x: 150, y: 100, radius: 15, angle: Math.PI, speed: 0.05 }
    ];
    let obstacles = [];
    let lights = [];

    const scoreDisplay = document.getElementById('score');
    const gameOverDisplay = document.getElementById('gameOver');
    const orbitInBtn = document.getElementById('orbitIn');
    const orbitOutBtn = document.getElementById('orbitOut');
    const resetBtn = document.getElementById('reset');

    function generateObstacles() {
      const newObstacles = [];
      for (let i = 0; i < 5; i++) {
        newObstacles.push({
          x: Math.random() * (canvas.width - 50) + 25,
          y: -50 - i * 150,
          radius: 20
        });
      }
      obstacles = newObstacles;
    }

    function generateLights() {
      const newLights = [];
      for (let i = 0; i < 3; i++) {
        newLights.push({
          x: Math.random() * (canvas.width - 20) + 10,
          y: -50 - i * 200
        });
      }
      lights = newLights;
    }

    if (!obstacles.length) generateObstacles();
    if (!lights.length) generateLights();

    function gameLoop() {
      if (gameOver) return;

      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Draw path
      ctx.beginPath();
      ctx.strokeStyle = '#ffffff';
      ctx.lineWidth = 5;
      for (let x = 0; x < canvas.width; x += 10) {
        const y = canvas.height / 2 + Math.sin(x * 0.02) * 50;
        ctx.lineTo(x, y);
      }
      ctx.stroke();

      // Update and draw stars
      stars = stars.map(star => {
        const newAngle = star.angle + star.speed;
        const newX = canvas.width / 2 + Math.cos(newAngle) * star.radius;
        const newY = canvas.height / 2 + Math.sin(newAngle) * star.radius + Math.sin(newX * 0.02) * 50;
        ctx.beginPath();
        ctx.arc(newX, newY, 5, 0, Math.PI * 2);
        ctx.fillStyle = '#ffd700';
        ctx.fill();
        return { ...star, x: newX, y: newY, angle: newAngle };
      });

      // Update and draw obstacles
      obstacles = obstacles.map(obs => ({ ...obs, y: obs.y + 2 }));
      if (obstacles[0]?.y > canvas.height) generateObstacles();
      obstacles.forEach(obs => {
        ctx.beginPath();
        ctx.arc(obs.x, obs.y, obs.radius, 0, Math.PI * 2);
        ctx.fillStyle = '#ff5555';
        ctx.fill();
      });
      obstacles = obstacles.filter(obs => obs.y < canvas.height);

      // Update and draw lights
      lights = lights.map(light => ({ ...light, y: light.y + 2 }));
      if (lights[0]?.y > canvas.height) generateLights();
      lights.forEach(light => {
        ctx.beginPath();
        ctx.arc(light.x, light.y, 3, 0, Math.PI * 2);
        ctx.fillStyle = '#00ffff';
        ctx.fill();
      });
      lights = lights.filter(light => light.y < canvas.height);

      // Collision detection
      stars.forEach(star => {
        obstacles.forEach(obs => {
          const dist = Math.hypot(star.x - obs.x, star.y - obs.y);
          if (dist < 15) {
            gameOver = true;
            stars = [];
            obstacles = [];
            lights = [];
            gameOverDisplay.classList.remove('hidden');
          }
        });
        lights.forEach((light, i) => {
          const dist = Math.hypot(star.x - light.x, star.y - light.y);
          if (dist < 10) {
            score += 10;
            scoreDisplay.textContent = score;
            lights.splice(i, 1);
          }
        });
      });

      requestAnimationFrame(gameLoop);
    }

    function handleInput(direction) {
      if (gameOver) return;
      stars = stars.map(star => ({
        ...star,
        radius: direction === 'in' ? Math.max(5, star.radius - 5) : Math.min(50, star.radius + 5)
      }));
    }

    function resetGame() {
      score = 0;
      gameOver = false;
      scoreDisplay.textContent = score;
      gameOverDisplay.classList.add('hidden');
      stars = [
        { x: 150, y: 100, radius: 10, angle: 0, speed: 0.05 },
        { x: 150, y: 100, radius: 15, angle: Math.PI, speed: 0.05 }
      ];
      obstacles = [];
      lights = [];
      generateObstacles();
      generateLights();
    }

    orbitInBtn.addEventListener('click', () => handleInput('in'));
    orbitOutBtn.addEventListener('click', () => handleInput('out'));
    resetBtn.addEventListener('click', resetGame);

    // Keyboard controls
    document.addEventListener('keydown', e => {
      if (e.key === 'ArrowLeft') handleInput('in');
      if (e.key === 'ArrowRight') handleInput('out');
      if (e.key === 'r' || e.key === 'R') resetGame();
    });

    gameLoop();
  </script>
</body>
</html>
